# Bifidobacterium dataset
In silico steps to find candidate genes for qPCR 

# Objective

Identifying phylogroup/phylotype specific genes that can be used in a real-time qPCR assay to quantifying their abundance
in fecal samples.

# Common steps taken for the computational analysis:

1. Fastqc paired-ended Illumina reads (see fastqc_raw_files.sh) [ref 1]
2. Trimming reads using trimmomatic (see trimming.sh) [ref 2] and fastqc using Fastqc (see fastqc_trimmed_files.sh) 
3. De novo assembly with Spades (see spades.sh) [ref 3]
4. Using Quast for quality control by eliminating contigs that were equal to 0 or >= 300 in length, or had a N50 <= 25000
        (see quast.sh) [ref 4]
        python(pandas) script used to filter out quality assemblies:
        data.loc[(data['# contigs'] == 0) | (data['# contigs'] >= 300) | (data['N50'] <= 25000)] (see bifido.pdf)
5. Genome annotation with Prokka (see prokka.sh) [ref 5]

Note: with the exception of Prokka, all other analyses were done on the HCC at UNL. Prokka was done on AWS. Please refer to this repository for instruction of how to install Prokka on AWS (https://github.com/jcgneto/installing_conda_and_prokka_aws). The reason to use Prokka on AWS is that it allowed us to customize the reference genome database inside the program to create a Bifidobacterium genus folder that used specific assemblies chosen by us. The list of assemblies can be found here (https://github.com/jcgneto/bifidobacterium/blob/master/list_reference_bifido_genomes.txt).
See prokka_genus.sh for the program used to create the genus database. Genomes were selected based on the status of the project (sequencing and assembly). We acknowledge the limitations of that strategy including, but not limited to: sample size.

# Phylogroup analysis:

Phylogroup determination was done using a GTR model-based phylogeny that had as input the core-genome alignment produced
by Roary, and here are the computational steps:

1. First, the common steps abovementioned were used to produce the .gff files with Prokka as input for Roary
2. Roary was used to produce the core-genome alignment (.aln) and pangenome files (gene_presence_absence.csv) (see roary.sh) [ref 6]
3. Phylogenetic tree was constructed using FasTree using a GTR model (see fastree.sh) [ref 7]
4. Phylogenetic tree visualization was done with Phandango using the bifidobacterium.tree generated by Fastree and
    gene_presence_absence.csv as input files (https://jameshadfield.github.io/phandango/#/) [ref 8]
5. Phylogroups were determined by inspection of the phylogram and pangenome heatmap. In total, we determined that there were 5 phylogroups in the dataset containing 18 genomes. (see bifido_pangenome_analysis.pdf) 

# Phylotype analysis

After defining the phylogroup structure, we have accessed the potential for phylogroup sub-division into phylotypes.
In order to do that the following steps were taken:

1. Run the common (general) steps in the analysis
2. Within each phylogroup (see phylogroup analysis above) we ran the snp-sites analysis [ref 9] using the roary output core_geneme_alignment.aln file as input (see scripts names below), followed by filtering putative recombination regions with Gubbins [ref 10] (see scripts names below) using the .aln file from snp_sites as input
        Scripts used are (> indicates the running order from left to right):
        **roary_phylogroup1.sh > snp_phylogroup1.sh > gubbins_phylogroup1.sh**
        
        **roary_phylogroup3.sh > snp_phylogroup3.sh > gubbins_phylogroup3.sh**
        
        **roary_phylogroup4.sh > snp_phylogroup4.sh > gubbins_phylogroup4.sh**
3. Gubbins not only filters recombination regions but generates a FasTree-based phylogenetic tree using the default         parameters chosen by Gubbins
4. Phylogenetic tree was visualized using Phandango, with the input files being .tree output from Gubbins plus
    gene_presence_absence.csv file from Roary to access the pangenome within each phylogroup
5. The combination of phylogenetic positioning and pangenome repertoire were used to define how many phylotypes existed
    within each phylogroup (see bifido_pangenome_analysis.pdf) 
    
# Identification of candidate genes that are phylogroup/phylotype specific 

The ultimate goal of the entire analysis was to identifying candidate genes that are uniquely present in either a
phylogroup or phylotype. If the phylogroup could not be broken down into phylotypes, then a candidate gene was defined as
phylogroup specific. Otherwise, phylotype specific genes were found by contrasting the phylotype pangenome data against the remainder genomes belonging to either the same phylogroup or others. Steps taken for that:

1. Run common steps, phylogroup and phylotype analyses as described above
2. Candidate gene identification was done combining the query_pan_genome function inside Roary and customed python/pandas scripts. The query_pan_genome function basically seeks to find genes uniquely present, or shared, between two sets of isolates or genomes. Our customed python scripts does virtually the same. We basically filter out all the shared genes from a pangenome matrix, identify candidates unquely present in each group, and lastly, we cross-check the presence of that gene across all phylogroups using crosstabs. The best candidates were selected on the followinng criteria: 1) Be present only in the target group; 2) Longer contigs or sequences; and 3) By avoinding core functions.
        Roary scripts used are listed below:
        **unique_phylogroup1.sh** (get a list of phylogroup1 unique genes)
        **unique_phylogroup2.sh** (get a list of phylogroup2 unique genes)
        **unique_phylogroup3.sh** (get a list of phylogroup3 unique genes)
        **unique_phylogroup4.sh** (get a list of phylogroup4 unique genes)
        **unique_phylogroup5.sh** (get a list of phylogroup5 unique genes)
        **phylogroup_1_phylotype_1.sh** (get a list of phylogroup_1_phylotype_1 unique genes)
        **phylogroup_1_phylotype_2.sh** (get a list of phylogroup_1_phylotype_2 unique genes)
        **phylogroup_4_phylotype_1.sh** (get a list of phylogroup_4_phylotype_1 unique genes)
        **phylogroup_4_phylotype_2.sh** (get a list of phylogroup_4_phylotype_2 unique genes)
        **phylogroup_4_phylotype_3.sh** (get a list of phylogroup_4_phylotype_3 unique genes)
        
## References

1. Andrews S. (2010). FastQC: a quality control tool for high throughput sequence data. Available online at: http://www.bioinformatics.babraham.ac.uk/projects/fastqc
2. Bolger A.M., et al. (2014). Trimmomatic: a flexible trimmer for Illumina sequence data. Bioinformatics, 30(15):2114-20. 
3. Bankevich A., et al. (2012). SPAdes: A New Genome Assembly Algorithm and Its Applications to Single-Cell Sequencing. Journal of Computational Biology, 19(5): 455–477.
4. Gurevich A., et al. (2013). QUAST: quality assessment tool for genome assemblies. Bioinformatics, 29(8):1072-1075.
5. Seemann T. (2014). Prokka: rapid prokaryotic genome annotation. Bioinformatics, 30(14):2068-9.
6. Andrew J., et al. (2015). Roary: rapid large-scale prokaryote pan genome analysis. Bioinformatics, 31(22):3691–3693.
7. Price M.N., et al. (2010). FastTree 2--approximately maximum-likelihood trees for large alignments.PLoS One, 5(3):e9490.
8. Hadfield J., et al. (2018). Phandango: an interactive viewer for bacterial population genomics. Bioinformatics, 34(2):292–293.
9. Page A.J., et al. (2016). SNP-sites: rapid efficient extraction of SNPs from multi-FASTA alignments. Microbial Genomics, 2(4).
10. Croucher N.J. (2014). Rapid phylogenetic analysis of large samples of recombinant bacterial whole genome sequences using Gubbins. Nucleic Acids Research, 43(3): e15. 

